import re
from itertools import chain
from math import copysign, floor, log10
from typing import Any, Sequence, Set, Tuple, Union

from doublemetaphone import doublemetaphone

from dedupe.cpredicates import initials, ngrams, unique_ngrams  # noqa: F401

# Each predicate function returns a collection of strings. Since order
# does not matter in such collections, a `set` would be the natural choice.
# However, the starting capacity of sets in CPython implementation is 4.
#   >>> sys.getsizeof({"a"})
#   216
#   >>> sys.getsizeof({"a","b","c","d"})
#   216
#   >>> sys.getsizeof({"a","b","c","d","e"})
#   472
# Many pradicate functions always return collections with just one
# (or zero) items. To avoid wasting too much memory we return tuples with
# just one (or zero) items whenever the output of a predicate function
# never contains more than one item and we return actual sets otherwise.

# Also keep in mind that when building sets or tuples it is always
# more efficient (looking at the generated bytecode) to define them
# using "literal expressions" rather than calling the constructor
# (mostly because it avoids the call to the constructor function):
#
#    >>> dis("set((1,2,3))")
#      0           0 RESUME                   0
#      1           2 PUSH_NULL
#                  4 LOAD_NAME                0 (set)
#                  6 LOAD_CONST               0 ((1, 2, 3))
#                  8 PRECALL                  1
#                 12 CALL                     1
#                 22 RETURN_VALUE
#    >>> dis("{1,2,3}")
#      0           0 RESUME                   0
#      1           2 BUILD_SET                0
#                  4 LOAD_CONST               0 (frozenset({1, 2, 3}))
#                  6 SET_UPDATE               1
#                  8 RETURN_VALUE


words = re.compile(r"[\w']+").findall
integers = re.compile(r"\d+").findall
start_word = re.compile(r"^([\w']+)").match
two_start_words = re.compile(r"^([\w']+\W+[\w']+)").match
start_integer = re.compile(r"^(\d+)").match
alpha_numeric = re.compile(r"(?=[a-zA-Z]*\d)[a-zA-Z\d]+").findall


def wholeFieldPredicate(field: Any) -> Tuple[str]:
    """return the whole field as a string"""
    return (str(field),)


def tokenFieldPredicate(field: str) -> Set[str]:
    """returns the tokens"""
    return {*words(field)}


def firstTokenPredicate(field: str) -> Union[Tuple[str], Tuple[()]]:
    first_token = start_word(field)
    if first_token:
        return first_token.groups()  # type: ignore
    else:
        return ()


def firstTwoTokensPredicate(field: str) -> Union[Tuple[str], Tuple[()]]:
    first_two_tokens = two_start_words(field)
    if first_two_tokens:
        return first_two_tokens.groups()  # type: ignore
    else:
        return ()


def commonIntegerPredicate(field: str) -> Set[str]:
    """return any integers"""

    # `str(int(i))` removes leading zeros, e.g. `str(int("0001")) = "1"`
    return {str(int(i)) for i in integers(field)}


def alphaNumericPredicate(field: str) -> Set[str]:
    return {*alpha_numeric(field)}


def nearIntegersPredicate(field: str) -> Set[str]:
    """for any integer N in field return the integers N-1, N and N+1"""
    string_ints = integers(field)
    near_ints = set()
    for s in string_ints:
        num = int(s)
        near_ints.add(str(num - 1))
        near_ints.add(str(num))
        near_ints.add(str(num + 1))

    return near_ints


def hundredIntegerPredicate(field: str) -> Set[str]:
    return {str(int(i))[:-2] + "00" for i in integers(field)}


def hundredIntegersOddPredicate(field: str) -> Set[str]:
    return {str(int(i))[:-2] + "0" + str(int(i) % 2) for i in integers(field)}


def firstIntegerPredicate(field: str) -> Union[Tuple[str], Tuple[()]]:
    first_token = start_integer(field)
    if first_token:
        return first_token.groups()  # type: ignore
    else:
        return ()


def ngramsTokens(field: Sequence[Any], n: int) -> Set[str]:
    grams = set()
    n_tokens = len(field)
    for i in range(n_tokens):
        for j in range(i + n, min(n_tokens, i + n) + 1):
            grams.add(" ".join(str(tok) for tok in field[i:j]))
    return grams


def commonTwoTokens(field: str) -> Set[str]:
    return ngramsTokens(field.split(), 2)


def commonThreeTokens(field: str) -> Set[str]:
    return ngramsTokens(field.split(), 3)


def fingerprint(field: str) -> Tuple[str]:
    return ("".join(sorted(field.split())),)  # removed last `.strip()`


def oneGramFingerprint(field: str) -> Union[Tuple[str], Tuple[()]]:
    # return set(("".join(sorted(unique_ngrams(field.replace(" ", ""), 1))),))  # removed last `.strip()`
    return ("".join(sorted({*field.replace(" ", "")})),)  # removed last `.strip()`


def twoGramFingerprint(field: str) -> Union[Tuple[str], Tuple[()]]:
    if len(field) > 1:
        return ("".join(sorted(unique_ngrams(field.replace(" ", ""), 2))),)
    else:
        return ()


def commonFourGram(field: str) -> Set[str]:
    """return 4-grams"""
    return unique_ngrams(field.replace(" ", ""), 4)


def commonSixGram(field: str) -> Set[str]:
    """return 6-grams"""
    return unique_ngrams(field.replace(" ", ""), 6)


def sameThreeCharStartPredicate(field: str) -> Set[str]:
    """return first three characters"""
    return initials(field.replace(" ", ""), 3)


def sameFiveCharStartPredicate(field: str) -> Set[str]:
    """return first five characters"""
    return initials(field.replace(" ", ""), 5)


def sameSevenCharStartPredicate(field: str) -> Set[str]:
    """return first seven characters"""
    return initials(field.replace(" ", ""), 7)


def suffixArray(field: str) -> Set[str]:
    suffixes = set()
    n = len(field) - 4
    if n > 0:
        for i in range(0, n):
            suffixes.add(field[i:])
    return suffixes


def sortedAcronym(field: str) -> Tuple[str]:
    return ("".join(sorted(each[0] for each in field.split())),)


def doubleMetaphone(field: str) -> Set[str]:
    return {metaphone for metaphone in doublemetaphone(field) if metaphone}


def metaphoneToken(field: str) -> Set[str]:
    return {
        metaphone_token
        for metaphone_token in chain(
            *(doublemetaphone(token) for token in field.split())
        )
        if metaphone_token
    }


def wholeSetPredicate(field_set: Sequence[Any]) -> Tuple[str]:
    return (str(field_set),)


def commonSetElementPredicate(field_set: Sequence[Any]) -> Set[str]:
    """return set as individual elements"""
    # return tuple([str(each) for each in field_set])
    return {*field_set}


def commonTwoElementsPredicate(field: Sequence[Any]) -> Set[str]:
    sequence = sorted(field)
    return ngramsTokens(sequence, 2)


def commonThreeElementsPredicate(field: Sequence[Any]) -> Set[str]:
    sequence = sorted(field)
    return ngramsTokens(sequence, 3)


def lastSetElementPredicate(field_set: Sequence[Any]) -> Set[str]:
    return {str(max(field_set))}


def firstSetElementPredicate(field_set: Sequence[Any]) -> Set[str]:
    return {str(min(field_set))}


def magnitudeOfCardinality(field_set: Sequence[Any]) -> Union[Tuple[str], Tuple[()]]:
    return orderOfMagnitude(len(field_set))


def latLongGridPredicate(
    field: Tuple[float], digits: int = 1
) -> Union[Tuple[str], Tuple[()]]:
    """
    Given a lat / long pair, return the grid coordinates at the
    nearest base value.  e.g., (42.3, -5.4) returns a grid at 0.1
    degree resolution of 0.1 degrees of latitude ~ 7km, so this is
    effectively a 14km lat grid.  This is imprecise for longitude,
    since 1 degree of longitude is 0km at the poles, and up to 111km
    at the equator. But it should be reasonably precise given some
    prior logical block (e.g., country).
    """
    if any(field):
        return (str(tuple(round(dim, digits) for dim in field)),)
    else:
        return ()


def orderOfMagnitude(field: Union[int, float]) -> Union[Tuple[str], Tuple[()]]:
    if field > 0:
        return (str(int(round(log10(field)))),)
    else:
        return ()


# Thanks to http://stackoverflow.com/questions/3410976/how-to-round-a-number-to-significant-figures-in-python
def roundTo1(
    field: float,
) -> Tuple[str]:
    abs_num = abs(field)
    order = int(floor(log10(abs_num)))
    rounded = round(abs_num, -order)
    return (str(int(copysign(rounded, field))),)
